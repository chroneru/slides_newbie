---
title: "newbie_workshop"
author: "chroneru"
date: "2018/4/24"
output:
  revealjs::revealjs_presentation:
    theme: sky
    self_contained: FALSE
    css: Css/newbie_workshop.css
  html_document: 
    css: Css/newbie_workshop_pages.css
---

```{r setup, include=FALSE}
#options(prompt = "#> $ ")
#options(continue = "#> $ ") #行末継続子
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  fig.show = "hold",
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "70%",
  fig.align = "center"
)
#TRUEでprompt表示
#knitr::opts_current$set(prompt=FALSE, eval = FALSE)
#rmarkdown::render("newbie_workshop.Rmd", "revealjs_presentation", "newbie_workshop.html")
#rmarkdown::render("newbie_workshop.Rmd", "html_document", "newbie_workshop_pages.html")

library(tidyverse)
library(DiagrammeR)
library(leaflet)
```

# 1.自己紹介

---

<div id="myprof">

* @chroneru_mineru
* R歴はぎゅっとすると2年ぐらい
* Rについてのブログを書いてる

</div>

# 2.Rのインストール

## windows

* [Rのページ](https://www.r-project.org/)に行きます。
* Mirrors からjapanのミラーサイトを選択してください。
* Download R x.x.x for Windowsをクリックしてダウンロードして実行する。(x.x.xはバージョンです。)
* 後はインストーラにしたがってください。

## mac

* homebrewでのインストールだとこんな感じ

```bash
brew tap homebrew/science
brew install r
```

## linux

* 簡易的な方法を示します。
* ubuntu

```bash
sudo apt-get install r-base
```

* centos

```bash
sudo yum install epel-release
sudo yum --enablerepo=epel install R
```

# 3.Rstudioのインストール

## windows

* [Rstudio](https://www.rstudio.com)のページからダウンロード，インストールします。
* 別に難しくない

## mac

* homebrewでのインストール
    * brew-cask必須！

```bash
brew cask install rstudio
```

## linux

* ubuntu

```bash
wget https://download1.rstudio.org/rstudio-1.1.447-amd64.deb
sudo dpkg -i rstudio-1.1.447-amd64.deb
```

* centos

```bash
sudo yum install wget
wget https://download2.rstudio.org/rstudio-server-rhel-1.1.442-x86_64.rpm
sudo yum install rstudio-server-rhel-1.1.442-x86_64.rpm
```

# 4.Rの演算子 {#operator}

## 算術演算子

* ふつうの計算に使う

| 演算子 | 使い方 | 結果  |
|:------:|-------:|------:|
|`+`     |`1 + 2` |`r 1+2`  |
|`-`     |`1 - 2` |`r 1-2`  |
|`*`     |`2 * 3` |`r 2*3`  |
|`/`     |`2 / 3` |`r 2/3`  |
|`^`     |`2 ^ 3` |`r 2^3`   |

## 代入演算子

* 代入に使う
* `=` は非推奨，`<-` を使う
* `<<-` はグローバル環境への代入
    * `<<-`よりもassign関数を使うほうがいい

| 演算子 | 使い方 |
|:------:|:------:|
|`<-`    |`a <- 3`|
|`<<-`   |`a <<- 5`|

# 5.データ型

## ベクトル

* Rではベクトルとして代入される。
* 文字列は`""`でくくる。
* 数値はそのまま代入
* 論理値は`TRUE`と`FALSE`

```{r vector}
hoge <- "やっほー"
fuga <- 1.414
foo <- TRUE
hoge; fuga; foo
```

---

* 複数の値を代入するときは`c()`を使う
    * 型強制が起こる
        * 数値は文字列に
        * 論理値は数値か文字列に

```{r combine_vectior}
hoge <- c("やっほー", "おっはー")
fuga <- c(1.414, 1.732)
foo <- c(TRUE,FALSE)
hoge; fuga; foo
```

```{r combine_vector2}
hoge2 <- c("やっほー", 1, TRUE)
fuga2 <- c(1.414, TRUE)
hoge2; fuga2
```

## クイズ

### 次のベクトルはどんなデータになるでしょう

```{r quiz_vector}
quiz1 <- c(1+TRUE, "やっほー")
quiz2 <- c(1+TRUE, 3) * FALSE
```

---

### 正解は

```{r ans_vector}
quiz1

quiz2
```

`TRUE`は`1`に，`FALSE`は`0`になります。

## リサイクルルール

* 小さいベクトルが，大きいベクトルにあわせて繰り返されます。
* ベクトルの長さによって警告が出る

---

```{r calc_vector}
a <- c(1,2,3,4)
b <- c(1,2)
c <- c(1,2,3)
```

```{r res_calc}
a * 3
a + b
b + a
a * c
```



## ベクトルの要素を参照する

<h3> ベクトルの要素は`[1]`からはじまる!</h3>

* ベクトルの参照は線形代数と一緒
* `[行番号,列番号]`で参照する!

```{r matrix}
a <- c(1,2,3,4)
dim(a) <- c(2,2) #2次元配列
a

a[1,2]

a[c(1,2),2]
```

---

* 代入もできる

```{r matrix_swap}
a

tmp <- a[2,1]
a[2,1] <- a[1,2]
a[1,2] <- tmp
a
```

## NA

* `NA`はNot Available
  * なにかわからない値に使う
* 特別な値


```{r na_ex}
na_vec <- c(NA, NA, NA)
is.na(na_vec)
na_vec + 1
na_vec == 1
na_vec == NA
na_vec != NA
```

## scanfみたいなのも用意されてる

* readline関数

```{r scan}
a <- readline("入力してね: ")

#> 入力してね: ここに入力
```

* これを使うと簡単なクイズができる。

---

### 作ってみよう。

```{r quiz_r}
quiz <- function() {
  answer <- "さくらんぼ"
  ans_u <- readline("おうとうってなんだ？: ")
  if (ans_u == answer) print("あってるよ") 
  else print("まちがってるよ")
}
quiz()
```




# 6.他言語との連携

# 6.1.C言語

---

* さっきのクイズをCにしてみると

```c
#include "/usr/include/stdio.h"
#include "/usr/include/stdlib.h"
#include "/usr/include/string.h"
#include "/usr/include/R/R.h"

void quiz(char **ans_u);

void quiz(char **ans_u) {
  char answer[] = "さくらんぼ";
  char yes[] = "あってるよ";
  char no[] = "まちがってるよ";

  printf("おうとうってなんだ？: %p\n",*ans_u);
  if(strcmp(answer,*ans_u) == 0) {
        printf("%s",yes);
  } else {
        printf("%s",no);
  }
}
```

---

* gccだとエラーは出ないが，危険っぽい

```bash
gcc -shared -fPIC -I/usr/include/R -o quiz_point.so quiz_point.c
```

* Rのバッチコマンドからビルドする

```bash
R CMD SHLIB quiz_point.c
```


```{r quiz,eval=FALSE}
dyn.load("./C/quiz_point.so")
ANS <- "さくらんぼ"
.C('quiz', as.character(ANS))
#> list()
#> おうとうってなんだ？: まちがってるよ
dyn.unload("./C/quiz_point.so")
```

---

* `R.h`のinclude必要!
* ヘッダファイルのincludeには絶対パスで指定するのが簡単
* `?.C`でデータ型を確認する
* gccも使える
    * gccのオプションでヘッダファイルのパスを指定する。
         * `-I/usr/include/R`
         * R.h内部でRconfig.hが呼び出されるため


## Cのコードはめんどい {#Ccompile}

* 関数の戻り値は`void`にする。
* 引数はポインタを使う。
* RのデータとCの引数の型とが一致しない
* gccだと.soをつくれてしまう
* Rバッチだとエラーの特定がしづらい

## Rからロード {#C2R}

* 形式は，`.so`か`.dll`
* `dyn.load(`"hoge.so"`)`で読み込む
* `dyn.unload(`"hoge.so"`)`でアンロード
    * Rはメモリだけで処理するのでアンロードしておくといい
    * fcloseぐらいに思っておく
* `.C('関数名',引数)`か`.Call()`を使う
* RにはC用のデータ型が用意されている

# 6.2.シェルスクリプト

## シェルスクリプト {#shellscript}

* シェルでも再現してみる。
* これはけっこう素直に扱える。

```{bash quiz_sh, results='hide', eval=FALSE}
#!/bin/sh

if [ $# -eq 1 ] 
then
        echo "おうとうってなんだ？"
        R --vanilla --no-save --slave -f ./quiz_sh.R --args $1

else
        echo "引数の数が正しくありません。"
fi
```

---

```{r quiz_sh_r, eval=FALSE}
ans_u <- commandArgs(trailingOnly = TRUE)

diagnosis <- c("まちがってるよ\n",
               "あってるよ\n")

cat( ans_u )
cat( "\n" )

cat(diagnosis[ (ans_u == "さくらんぼ") + 1 ])
```

```bash
chmod u+x quiz_sh.sh
```

## commandArgs()

* `trailingOnly = TRUE`を指定する。
    * `FALSE`だとコマンドとオプションも渡される。
* Rコマンドのオプションに`--args`を指定する。
* 引数を複数わたすこともできる。

## shebang

* シバンを変えることで`.R`スクリプトを直接実行できる。

```bash
#! /usr/bin/R --vanilla --no-save --slave -f

quiz <- function() {
  answer <- "さくらんぼ"
  ans_u <- readline("おうとうってなんだ？: ")
  if (ans_u == answer) print("あってるよ") 
  else print("まちがってるよ")
}
quiz()
```

```bash
chmod u+x ファイル名
```

## ヒアドキュメント {#program_with_heredoc}

* シェルのヒアドキュメントも使える

```bash
R --vanilla --no-save --slave << EOF
quiz <- function() {
  answer <- "さくらんぼ"
  ans_u <- readline("おうとうってなんだ？: ")
  if (ans_u == answer) print("あってるよ") 
  else print("まちがってるよ")
}
quiz()
\EOF
```

# 6.3.他にも使える言語 {#other_languages}

---

* C++
* Python
* Ruby
* SQL
* Haskell
* Rust

などなどいろいろ用意されている。

# 7.パッケージ

## パッケージとは

<h3>いろんな人がつくった便利な関数群</h3>

* `install.packages()`でインストール
* `library()`で読み込み
    * `require()`を使う人もいる。
* `detach()`でアンロード

```{r pkg_func, eval=FALSE}
install.packages("パッケージ名")
library(パッケージ名)
detach("package:パッケージ名", unload = TRUE)
```

## ヒアドキュメント {#install_with_heredoc}

* ヒアドキュメントでログをとる。
* インストール失敗時にべんり!
* windowsは使えない。

```bash
R --no-save << EOF > logfile 2>&1
install.packages("パッケージ名")
\EOF
```

## tidyverse群

* よくつかわれるパッケージをまとめたもの
* データ処理につかう
* パイプ`%>%`が使える
* グラフをきれいにかける

---

```{r hadley_pkg, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
```

* インストール時につまづきやすい
* エラーを読むと解決する

## tidyverseの実践 {#tidy_example}

* ggplotについての例を示す
* tidyverseパッケージが必要
* ggplot2でもOK

```{r ready_tidyverse, eval = FALSE}
library(tidyverse)
```


## ggplot

* グラフをつくる関数
* レイヤーを重ねる
* 階層グラフィックス文法っていう書き方
* `geom`関数でプロットの形式を変えれる
* `ggsave()`で簡単にプロットを保存できる

とりあえずここまでにしておく。

---

```{r ggplot_ex, eval=FALSE}
mtcars_tibble <- as_tibble(mtcars)
ggplot(
  data = mtcars_tibble,
  mapping = aes(
    x = mpg,
    y = disp,
    color = cyl
    )
  ) +
  geom_point()
```

* tibbleという型をつかう
* `+`で関数をつなぐ

---

![mtcars_tibble](Image/newbie_workshop_image/mtcars_tibble.png)

# 8.関数

## function()

* `function()`をつかう。
* ()のなかに引数をあたえる。
* 中のプログラムは`{}`でくくる。

## 関数例:パレート図の統計量

<h3> あんまりよくない</h3>

* 個数を数える
* 大きいものからならべる(desc)
* 一個前のを自身に足す
* 割合を計算する

---

```{r pareto_func}
pareto_func <- function(vec) {

res_count <- c("a" = NA, "b" = NA, "c" = NA, "d" = NA, "e" = NA)
for(moji in c("a", "b", "c", "d", "e")) {
    res_count[moji] <- sum(vec == moji)
}
res_count <- sort(res_count, decreasing = TRUE)
res_pareto <- cumsum(res_count)
res_pareto <- res_pareto / res_pareto[5]
list("count" = res_count, "density" = res_pareto)
}
```

* 一般化していない
* あとでつかってみます

---

* 引数は，仮引数
    * `function(a = 5)`のようにデフォルトも設定できる
* `c("a" = NA)`で名前を与えられる。
    * `names(ベクトル)`で名前を確認できる。
* `sort()`はならべかえ
* `cumsum()`は累積和

```{r cumsum_ex}
cumsum( c(1, 2, 3, 4, 5))
```

# 9.データ

## read.csv

* 標準で使える読み込み関数
* `stringAsFactors = FALSE`にする
    * 文字列が変化するのを防ぐ
    
```r
read.csv("ファイル名", stringAsFactors = FALSE)
```

## read_csv

* tidyverse群に用意されてる関数(readr)

```r
read_csv(
  "ファイル名",
  locale = locale(encoding = "エンコード")
)
```

## write.csv

* 標準のcsv作成関数
* `row.names = FALSE`
    * 行名が追加されるのを防ぐ

## サンプルデータの作成

* Rにはさまざまなデータ作成関数がある
* `sample()`
* `runif()`
* `rnorm()`
* `rgamma()`

## sample

* `sample()`で単純なデータを作成できる
* `size`は何個とりだすか
* `replace`は複数回とりだせるか
* `prob`は確率を指定する。
    * 合計が1じゃなくても大丈夫

```{r sample_ex}
sample(1:100, size = 2)
```

## その他

|  関数   | 確率分布 |   使い方   |
|:-------:|:--------:|:-----------:
|`runif()`|一様分布|`runif(5)`|
|`rnorm()`|正規分布|`rnorm(5)`|
|`rgamma()`|ガンマ分布|`rgamma(5,shape = 2, rate = 5)`|
|`rbeta()`|ベータ分布|`rbeta(5, shape1 = 0.5, shape2 = 0.5)`|

* shapeはk, rateはシータ
* shape1はα, shape2はβ

# 10.使用例

## パレート図 {#pareto_graph}

```{r pareto_play}
prob_vec <- sample(1:5, size = 5)
vec1 <- sample(
  1:5,
  size = 10000,
  replace = TRUE,
  prob = prob_vec
)
replace_abcde <- function(vec1) {
  num <- 1
  for(moji in c("a", "b", "c", "d", "e")) {
    vec1[vec1 == num] <- moji
    num <- num + 1
  }
  assign("vec1", vec1, envir = parent.env(environment()))
}
replace_abcde(vec1)
result <- pareto_func(vec1)
result
```

---

* 図にすると

```{r pareto_tibble}
result <- as_tibble(result) %>% 
  mutate(
    name = names(result$count),
    count_density = count / sum(count)
  )
```

---

```{r pareto_graph, fig.show = "hide"}
result %>% 
  ggplot() +
  geom_hline(
    yintercept = c(0.7,0.9,1),
    size = 0.2,
    color = "#ff0000"
  ) +
  geom_bar(
    aes(name, count_density, fill = density),
    stat = "identity"
  ) +
  geom_line(aes(name, density, group ="1")) +
  geom_point(
    aes(name, density, color = density),
    size = 5
  ) +
  scale_x_discrete(limits = result$name) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.1)) +
  scale_color_gradient(low = "#006600", high = "#ccffcc") +
  scale_fill_gradient(low = "#006600", high = "#ccffcc") +
#  viridis::scale_fill_viridis(option="inferno") +
#  viridis::scale_color_viridis() +
  coord_cartesian(ylim = c(0,1)) +
  labs(
    x = names(result$count),
    y = NULL
    ) +
  theme(legend.position = "none")

# ggsave("pareto_graph.png")
```

[見やすい方](newbie_workshop_pages.html#pareto_graph)

---

```{r import_pareto_graph, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", echo=FALSE}
knitr::include_graphics("Image/newbie_workshop_image/pareto_graph.png")
```

# 11.統計処理

## とりあえずやってみる。

* `ToothGrowth`というデータセットを使ってみる

```{r ToothGrowth_data}
head(ToothGrowth)
class(ToothGrowth)
```

---

* モルモットの歯のデータセット
    * `VC`かオレンジジュース(`Oj`)の用量と歯の長さ

```{r import_guinea-pig, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", echo=FALSE}
knitr::include_graphics("Image/newbie_workshop_image/guinea-pig-242520_1920.jpg")
```


## 方針

1. tidyverse群がつかえるようにtibbleにする。
1. 列名をわかりやすくする
1. とりあえず散布図を作る
1. 他の処理について考える 

## tibble型の威力

```{r ToothGrowth_2_tibble}
ToothGrowth2 <- as_tibble(ToothGrowth)
ToothGrowth2 %>% head(2) %>% knitr::kable()
ToothGrowth2 %>% tail(2) %>% knitr::kable()
```

## 列名を変更する

* ここは参考ぐらいに

```{r ToothGrowth2_names}
names(ToothGrowth2) <- c("Tooth_length", "Supplement", "Dose")
ToothGrowth2 %>% head() %>% knitr::kable()
```

## 散布図で様子見

```{r ToothGrowth2_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
ToothGrowth2 %>% 
  ggplot(aes(Dose, Tooth_length, color = Supplement)) +
  geom_point()
```

## 線形回帰分析

* `lm()`を使う

```{r ToothGrowth2_lm}
ToothGrowth2_VC_lm <- lm(Tooth_length ~ Dose, data = ToothGrowth2 %>% filter(Supplement == "VC"))
ToothGrowth2_OJ_lm <- lm(Tooth_length ~ Dose, data = ToothGrowth2 %>% filter(Supplement == "OJ"))
ToothGrowth2_lm <- list(VC_lm = summary(ToothGrowth2_VC_lm), OJ_lm = summary(ToothGrowth2_OJ_lm))
ToothGrowth2_lm$VC_lm$coefficients; ToothGrowth2_lm$OJ_lm$coefficients
ToothGrowth2_lm$VC_lm$coefficients; ToothGrowth2_lm$VC_lm$coefficients

# Tooth_length = 3.295 + 11.716 * Dose
# Tooth_length = 11.550 + 7.811 * Dose
```

---

* 回帰直線のプロット

```{r ToothGrowth2_lm_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
ToothGrowth2 %>% 
  group_by(Supplement) %>% 
  ggplot(aes(Dose, Tooth_length, color = Supplement)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```


# 12.ベイズ

## ベイズ統計

* ToothGrowthでは母集団が少ない。
* なにもしていない時の歯の増加量がわからない。
* 特に事前情報がない。

<br/>

<h2>そんなときはベイズ</h2>

## baysian linear regression

* 要は線形回帰分析

```{r ToothGrowth2_lm_MCMC}
ToothGrowth2_VC_bayes_lm <- MCMCpack::MCMCregress(Tooth_length ~ Dose, ToothGrowth2 %>% filter(Supplement == "VC"), verbose = 10000)
ToothGrowth2_OJ_bayes_lm <- MCMCpack::MCMCregress(Tooth_length ~ Dose, ToothGrowth2 %>% filter(Supplement == "OJ"), verbose = 10000)
ToothGrowth2_bayes_lm <- list(VC_bayes_lm = summary(ToothGrowth2_VC_bayes_lm), OJ_bayes_lm = summary(ToothGrowth2_OJ_bayes_lm))
ToothGrowth2_bayes_lm
```

---

```{r}
Intercept <- c(ToothGrowth2_bayes_lm$VC_bayes_lm$statistics[1,1],
                ToothGrowth2_bayes_lm$OJ_bayes_lm$statistics[1,1])
slope <- c(ToothGrowth2_bayes_lm$VC_bayes_lm$statistics[2,1],
                ToothGrowth2_bayes_lm$OJ_bayes_lm$statistics[2,1])
Intercept; slope

```

---

```{r ToothGrowth2_lm_MCMC_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", eval=FALSE}

ToothGrowth2 %>% 
  group_by(Supplement) %>% 
  ggplot(aes(Dose, Tooth_length, color = Supplement)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, size = 2) +
  stat_function(
    fun = function(Dose)  Intercept[1] + slope[1] * Dose,
    geom = "line",
    color = "#00ffc4",
    size = 0.6,
    xlim = c(0.5, 2.0),
    show.legend = TRUE
  ) +
  stat_function(
    fun = function(Dose) Intercept[2] + slope[2] * Dose,
    geom = "line",
    color = "#ffe4f1",
    size = 0.5,
    xlim = c(0.5, 2.0),
    show.legend = TRUE
  )
```



## MCMCregress

* `MCMCpack`パッケージを使う。
* `MCMCpack::MCMCregress`でMCMC法での回帰直線を作成する。
* デフォルトでバーンインは1000回,イテレーションは10000回
* verboseを設定すると進行状況と各変数の確率分布を`print`で表示できる。

---

MCMC法による線形回帰の結果を通常の線形回帰分析と重ねあわせてみると 

* だいたいおなじ
* あくまで目安


```{r import_ToothGrowth2_lm_MCMC_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", echo=FALSE}
knitr::include_graphics("./Image/newbie_workshop_image/bayes_and_lm_plot.png")
```


# 13.BayesFactor

## ベイズファクター

* 尤度を比較する指標
* 事後確率の比と事前確率の比の比
    * すごいわかりづらい

<br/>

<h2 id="h2_alone">ある仮説のときにデータがこうなってるよね?<br/>
これって別の仮説の時のデータだとしたらどっちいいんかな?ってこと</h2>

## anovaBF

* `BayesFactor::anovaBF`
    * 分散を解析する関数
* factorじゃないと使えないらしい
* 質的変数として扱えるならそうする
    * Doseは比例尺度と考えられる(量的変数)
    * 今回は順位尺度と見る

```{r anovaBF_error, error=TRUE}
bf <- BayesFactor::anovaBF(
  Tooth_length ~ Dose,
  data = ToothGrowth2
  )
```

## anovaBFの使用

* 公式にのっとってデータを整理していく

```{r anovaBF_2_factor}
ToothGrowth2$Dose <- factor(ToothGrowth2$Dose)
levels(ToothGrowth2$Dose) <- c("Low", "Medium", "High")
```

---

```{r calc_anovaBF}
bf <- BayesFactor::anovaBF(
  Tooth_length ~ Supplement * Dose,
  data = ToothGrowth2
  )
bf
```

---

* 今回はplotが用意されているので`plot()`を使う

```{r calc_anovaBF_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", echo=FALSE}
display_plot <- matrix(c(1, 0, 1, 0), 2, 2)
layout(display_plot)
plot(bf)
plot(bf[3:4]/bf[2])
```

## プロット結果

* 見た感じ`Supplement`は関係なさそう
* `Supplement + Dose + Supplement:Dose`で仮設を立てるのが最も良さそう

というわけで`factor`を`numeric`にするんですが 
少し失敗しました。笑 

```{r ToothGrowth2_2_numeric}
levels(ToothGrowth2$Dose) <- c(0.5, 1, 2)
ToothGrowth2$Dose <- as.numeric(as.character(ToothGrowth2$Dose))
str(ToothGrowth2$Dose)
```

## ふたたび線形回帰分析

* 手順は同じ

```{r ToothGrowth_lm_result}
# Tooth_length = b0 + b1*Supplement + b2*Dose + b3*Supplement*Dose
ToothGrowth_lm_result <- lm(Tooth_length ~ Supplement * Dose, data = ToothGrowth2)
summary(ToothGrowth_lm_result)
```

---

* ggplotを使っていく
* [見やすい方](newbie_workshop_pages.html#ToothGrowth_lm_result_table)



```{r ToothGrowth_lm_result_table}
ToothGrowth2 <- ToothGrowth2 %>% 
  mutate(
    Supplement_num = unclass(.$Supplement),
    Tooth_length_res = predict(ToothGrowth_lm_result)
  )
ToothGrowth2 %>% head() %>% knitr::kable()
```

---

```{r ToothGrowth_lm_result_plot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center", echo=FALSE}
par(mfrow = c(2, 2))
plot(ToothGrowth_lm_result)
```

* 残差が同じぐらいの広がり
* 正規性が見て取れる
* クックの距離が0.5を超えているようなので当てはまりもよさそう

---

```{r ToothGrowth_lm_result_ggplot, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
ToothGrowth2 %>% 
  ggplot(aes(Dose, color = Supplement)) +
  geom_point(aes(y = Tooth_length_res), position = position_jitter(width = 0.1, height = 1), color = "#0000ff") +
  geom_point(aes(y = Tooth_length), position = position_jitter(width = 0.1))
```

---

* 95%信頼区間でのみ`b3 * Supplement * Dose`が棄却される。
* イテレーションしたらもう少し違うかも。

# 14.rmarkdown

## rmarkdownの準備

* File > New File > R markdown > Document HTML(ラジオボタン) > OK
* はじめてrmdファイルを作ろうとするとエラーが出る
* とりあえず，インストールしてください。

```{r , eval=FALSE}
install.packages(c("bitops", "caTools"))
```

## yamlヘッダ

* 出力するファイルのオプションを設定

<pre>
---
title: "たいとる"
author: "書いた人"
date: "日付"
output: 出力形式: 
    css: "cssのパス"
    self_contained: TRUEかFALSE
---
</pre>

## 出力形式

|指定方法|出力形式|
|:------:|:------:|
|html_document|html|
|pdf_document|pdf|
|word_document|word|
|ioslides_presentation|htmlのスライド|
|revealjs::revealjs_presentation|イケてるスライド|
|bookdown::gitbook|本|

* 他にもいろいろな出力形式がある。
* pdfはlatexをつかうので、ハマる。

---

```{r install_revealjs, eval=FALSE}
#CRANから
install.packages("revealjs")

#githubから
install.packages("devtools")
install_github("rstudio/revealjs")
```

```{r install_bookdown, eval=FALSE}
install.packages("bookdown")
```

## pdfの出力

* pdfを出力するとエラーが出る
* texライブラリが足りないみたい

<pre>
output: pdf_document
    
Ctrl + Shift + K (knit)
</pre>

## texのログファイル

* pdfをレンダリングするとログが出るので読む
    * 大事なところだけでいい

<pre>
! LaTeX Error: File `titling.sty' not found.
!  ==> Fatal error occurred, no output PDF file produced!
</pre>

* `titling.sty`がないということ

## texライブラリ

* texライブラリを追加すればOK

```bash
wget ftp://ftp.jaist.ac.jp/pub/CTAN/macros/latex/contrib/titling.zip
unzip titling.zip
cd titling.zip
latex titling.ins
sudo cp titling.sty /usr/share/texlive/texmf-dist/tex/latex/titling/
sudo texhash
```

* 必要ないかもだけど一応

<pre>
# You are recommended to install the tinytex package to build PDF.FALSE
On Rstudio
install.packages("tinytex")
</pre>

# 15.コードチャンク

## コードチャンクの書き方

* 先頭の\\はエスケープです。
* 取り除いてください。

<pre>
\```{r}
\Rのコード 
\``` 
</pre>

* `Ctrl + Alt + I` でチャンクを追加できる

## チャンクオプション

* `{r チャンク名, オプションの指定}`

|オプション|T, F| 結果 |
|:--------:|:--:|:----:|
|include   |FALSE|コードと結果を表示しない|
|echo      |FALSE|コードを表示しない|
|message   |FALSE|メッセージを表示しない|
|eval      |FALSE|実行しない|

* ほかにもいろいろある
* オプションのチェック方法
    * `knitr::opts_chunk$get`

## setupチャンク

* `{r setup, include = FALSE}`
* setupのチャンクは一度しか使えない。
* `include = FALSE`がよく使う指定。
    * コードチャンクを表示しない

---

* 今回は次のように設定してある。
* bookdownは違う設定をしてある。

<pre>
\```{r setup, include=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  fig.show = "hold"
)
\```
</pre>

## エンジン

* `{r チャンク名, engine="言語名"}`
* ````言語名:チャンク名`
* `{言語名 チャンク名, オプション}`

[他言語](#other_languages) に書いた言語以外にもいろいろ使える。

## tex数式 {#tex_math}

* インラインは`$数式$`
* ブロックラインは`$$数式$$`

たとえば,$E=mc^2$, $mgh=\frac{1}{2}mv^2$

$$E=mc^2$$
$$mgh=\frac{1}{2}mv^2$$

## texコマンド {#tex_command}

* コマンドは\\をつける

|コマンド|効果|
|:-------:|:--------:|
|`\text`  | 演算子など記号を文字にする |
|`{\rm }` | 文字がイタリックになるのをやめる|
|`_{}`    | 下付き文字 |
|`^{}`    | 上付き文字 |
|`\theta` |$\theta$ギリシャ文字(ほかにも使えます)|
|`\frac{a}{b}`|$\frac{a}{b}$の分数をつくる|
|`\int_a^b`|$\int_a^b$こんな感じの積分を作る|


# 16.shiny

## shinyってなんぞ

* Rでwebアプリを作れるやつ
* shinyパッケージをインストールする
* ここ数年で仕様が変化している模様
    * ui.Rとserver.Rからapp.Rに
* shinyサーバーをインストールして構築するのは難易度高め
* shinyserverproを使うとユーザー認証ができたりする。

* ここからは`eval=FALSE`にしてある
    * shinyのある環境でお試しください。

---

* 簡単に書いてみると

```{r , eval=FALSE}
ui <- fluidPage(
  titlePanel("たいとる"),
  mainPanel(),
  sidebarPanel()
)

server <- function(input, output) {
  
}

shinyApp(ui = ui, server = server)
```

---

* ui.Rでの場合
    * `shinyUI()`でui設定を`{}`でくくって記述
* server.Rでの場合
    * `shinyServer()`でserver設定を`function(input,output){}`の関数内で記述
* app.Rでの場合
    * `ui`,`server`オブジェクトを定義
    * `shinyApp(ui = ui, server = server)`でアプリ起動


## widget

* さっきのはシンプルな形
* 入力フォームや出力などのウィジェットを定義する。

```{r Input_check}
ls(envir = environment(shiny::numericInput)) %>% 
  # ..*で任意の一文字以上, (Input|Output)でInputまたはOutput, $は行末のアンカー
  str_subset("..*(Input|Output)$") 
```

---

```{r , eval=FALSE}

ui <- fluidPage(
  titlePanel("numericInput&sliderInput"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  textOutput("test_text")
)

server <- function(input, output) {
  output$test_text <- renderText({
    paste0("入力した数字は,", input$test_num, "スライダーの数字は,", input$test_slide)
  })
}

shinyApp(ui = ui, server = server)
```

* `output$id名`に出力を代入する。

---

* render系の関数は出力時に使う。

```{r}
ls(envir = environment(shiny::renderText)) %>% 
  str_subset(".*render.*")
```


    
## reactive

<h3>いままでやったのはreactivityとは少し違う。</h3>

* `render*`はinputの値が変わるたびに、再実行する。
* つまり、不要な更新も行われるということ。
* さっきの例だと
    * `numericInput`の値しか変わらないのに`sliderInput`の値を再代入してしまう。

<h3>`reactive()`を使おう!</h3>

## reactiveを使ってみる。

```{r test_reactive, eval=FALSE}
ui <- fluidPage(
  titlePanel("numericInput&sliderInput"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  textOutput("test_text")
)

server <- function(input, output) {
  reactive_test_num <- reactive(list(input$test_num, input$test_slide))
  output$test_text <- renderText({
    paste0("入力した数字は,", reactive_test_num()[[1]], "スライダーの数字は,", reactive_test_num()[[2]])
  })
}

shinyApp(ui = ui, server = server)

```

* `reactive`は関数オブジェクトの形をとる。
* `[[]]`でのアクセスは、ベクトルを返させる。

---

* `reactive`の関数は、`{}`でくくると複数行の表現式を受け取れる。
* `reactive`は、メモリ中の`input`変数が変わったら、再実行される。
    * 変わらなければ再代入されない。
* なんども関数を実行することは速度の低下につながる。

## observer

* `observe`は常に`input`を監視する。
* 挙動は`reactive`と同じ。

```{r , eval=FALSE}
ui <- fluidPage(
  titlePanel("numericInput&sliderInput"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  textOutput("test_text")
)

server <- function(input, output) {
  #observe(list(input$test_num, input$test_slide))
  observe_test <- reactiveValues()
  observe({observe_test$num <- input$test_num; observe_test$slide <- input$test_slide})
  output$test_text <- renderText({
    paste0("入力した数字は,",
           #input$test_num,
           observe_test$num,
           "スライダーの数字は,",
           #input$test_slide
           observe_test$slide)
  })
}

shinyApp(ui = ui, server = server)
```

---

* `observe()`は,`reactive`と決定的に違う。
* `input`が変わらなくても、`observe`内の関数を再実行する。
    * `render*`内の関数を外に押し出すのにいいかも。



## endpoint

* `render*`の関数

```{r  fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
mermaid("
        graph LR
          id1[reactive]
          id2{observer}
          id3>endpoint]
        
          id1---id2
          id2---id3")
```

---

* イメージとしてはこんな感じ
* 最後に`render*`で`output`にわたす
    * `renderText()`をさっき使った
* `mermaid()`は後述


```{r test_render_table, eval=FALSE}
ui <- fluidPage(
  titlePanel("numericInput&sliderInput"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  dataTableOutput("test_table")
)

server <- function(input, output) {
  check_var <- reactive(data.frame(num = input$test_num, slide = input$test_slide))
  observe({table_1 <- as.data.frame(check_var())})
  output$test_table <- renderDataTable({as.data.frame(check_var())})
}

shinyApp(ui = ui, server = server)
```

---

* `renderDataTable()`はdata.frameとmatrixを出力
* `renderTable()`は`xtable::xtable`を使うので注意！
* 詳しくは`?shiny::renderDataTable`

<h3>基本的には, reactive, endpoint, がわかればOK!</h3>

# 17.shinyのレイアウト

## \*Panel

* 基本的には`*Panel`で書けばいい。
* `sidebarLayout()`も簡単

```{r ls_Panel}
ls(envir = environment(shiny::titlePanel)) %>% 
  str_subset(".*Panel$")
```


## fluidRow

* `fluidRow()`の中に`column(width, )`でレイアウトしていく
    * いままで使ってたやつ
* `column(width, )`のwidthは,同一の`fluidRow()`内で合計12になるようにする。
    * 2つに等分するなら`width = 6`
    * 3等分なら`width = 4`
    * 自由に、`width = 2`, `width = 4` , `width = 6`もOK

## css

1. app.R, ui.R, server.Rのあるところにcssを置く
1. `shiny::includeCSS()`でcssファイルを指定する。(パス無し)

1. `www`ディレクトリをapp.R, ui.R, server.Rのあるところに作る
1. `www`内にcssファイルを置く
1. `fluidPage(theme = "css", )`で指定する。
1. `tags$head()`内の`tags$link()`で設定する

* `tags$head()`内の`tags$style()`で直接スタイルを書く

---

```{r test_shiny_css, eval=FALSE}
ui <- fluidPage(
  #失敗,たぶんリポジトリのディレクトリ構造が干渉してる
  # theme = "shiny_css/test_shiny_css.css",
  #失敗,たぶん上と同じ理由
    # tags$head(
    #   tags$link(rel = "stylesheet", type = "text/css", href = "shiny_css/test_shiny_css.css")
    # ),
  #これはうまくいく。パスはRmd起点にしてある。
  #includeCSS("www/shiny_css/test_shiny_css.css"),
  
  headerPanel("numericInput&sliderInput"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  dataTableOutput("test_table")
)

server <- function(input, output) {
  check_var <- reactive(data.frame(num = input$test_num, slide = input$test_slide))
  observe({table_1 <- as.data.frame(check_var())})
  output$test_table <- renderDataTable({as.data.frame(check_var())})
}

shinyApp(ui = ui, server = server)

```

* ちょー見づらいけど、テストだからわかりやすく。

## googleapi

* googleapiのcssを`@import`する
* 日本語は開発中らしい
* earlyaccessでcssを読み込める

```{r import_font_css, eval=FALSE}
ui <- fluidPage(
  tags$head(
    tags$style(HTML("
/*
                    @import url(//fonts.googleapis.com/earlyaccess/nicomoji.css);
                    h1, h2, h3, h4, h5, h6, p {
                      font-family: 'Nico Moji', cursive;
                    }
*/

/*
                    @import url(//fonts.googleapis.com/earlyaccess/hannari.css);
                    h1, h2, h3, h4, h5, h6, p {
                      font-family: 'Hannari', serif;
                    }
*/
                    "))
  ),
  
  headerPanel("数字の入力練習"),
  fluidRow(
    column(6,
           numericInput("test_num", "数字を入力してね", value = NA, min = 0, max = 20)),
    column(6,
            sliderInput("test_slide", "スライドしよう", min = 0, max = 100, value = 20))
  ),
  dataTableOutput("test_table")
)

server <- function(input, output) {
  check_var <- reactive(data.frame(num = input$test_num, slide = input$test_slide))
  observe({table_1 <- as.data.frame(check_var())})
  output$test_table <- renderDataTable({as.data.frame(check_var())})
}

shinyApp(ui = ui, server = server)

```




# 18.htmlwidgets

## htmlwidgetsとは

* javascriptをつかってRをインタラクティブにしようってこと
* html系ならなんでも組み合わせられる
* ただし、相互干渉の可能性あり
* (いっぱいあります)[http://gallery.htmlwidgets.org/]
    * 今回は`leaflet`と`DiagrammeR`を紹介
    * 主に`DiagrammeR`

## leaflet

* いけいけなマップを生成する。

```{r  process_leaflet, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
# ダブルクウォーテーションを使う
mermaid('
        graph LR
        first["leaflet()"]
        second["addTiles()"]
        last[他の情報]
        
        first --> second
        second --> last')
```

---


```{r Hakodate_ShinHakodate}

map_df <- data.frame(
  popup = c("はこだて", "函館駅", "新函館北斗駅", "MIRAI BASE"),
  lng = c(140.72881, 140.7277, 140.648376, 140.757159),
  lat = c(41.768793, 41.773269, 41.904698, 41.814461)
)

# 函館駅と新函館駅を結ぶ
leaflet() %>% 
  addTiles() %>% 
  addMarkers(lng = map_df$lng[2:3], lat = map_df$lat[2:3], popup = map_df$popup[2:3]) %>% 
  addPolylines(lng = map_df$lng[2:3], lat = map_df$lat[2:3])
```

## Leaflet Route Machine

* 経路探索用のleafletプラグイン
* まだ`leaflet`には用意されてない。
* `rMaps`を使う。
    * `rCharts`が依存関係

```bash
R --no-save << EOF > install_rCharts.log 2>&1
devtools::install_github("rmnathv/rCharts")
\EOF
```

```bash
R --no-save << EOF > install_rMaps.log 2>&1
devtools::install_github("rmnathv/rMaps")
\EOF
```

---

* 絶賛失敗中です。
* jsコード読んでないのでどこが悪いかわからない。
* そのうち完成させます。

```{r route_search,eval=FALSE}
library(rMaps); library(leaflet)
map <- Leaflet$new()
map$setView(c(map_df$lat[1], map_df$lng[1]), zoom = 15)
#map$marker(c(map_df$lat[2], map_df$lng[2]), bindpopup = map_df$popup[2])
#map$marker(c(map_df$lat[4], map_df$lng[4]), bindpopup = map_df$popup[4])
map$addAssets(css = c("https://unpkg.com/leaflet@1.2.0/dist/leaflet.css", "https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"),
              jshead = c("https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js", "https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"))
map$setTemplate(afterScript = sprintf("
<script>
  L.Routing.control({
    waypoints: [
      L.latlng(41.77327, 140.7277),
      L.latlng(41.81446, 140.7572)
    ]
}).addTo(map);
</script>
"))
map
```


## libpng

* `leaflet`のインストール時にエラーが出る場合がある。

```
/bin/sh: libpng-config: command not found
read.c:3:17: 致命的エラー: png.h: No such file or directory
 #include <png.h>

 ERROR: compilation failed for package ‘png’
```

---

* 一応、失敗例も
* wget以下が成功例

```bash
# 失敗
sudo yum install libpng-config

# 失敗
sudo yum install libpng.x86_64

wget http://prdownloads.sourceforge.net/libpng/libpng-1.6.34.tar.gz
tar zxvf libpng-1.6.34.tar.gz
cd libpng-1.6.34
./configure
make
sudo make install

export CPLUS_INCLUDE_PATH=/usr/local/include
export LD_LIBRARY_PATH=/usr/local/lib
export LIBRARY_PATH=/usr/local/lib
```

---

```bash
R --no-save << EOF > install_png.log 2>&1
install.packages("png")
\EOF
```

```bash
R --no-save << EOF > install_leaflet.log 2>&1
install.packages("leaflet")
\EOF
```


# 19.DiagrammeR

## DiagrammeRとは

* `graphviz`と`mermaid`が主力
* パイプを使った図の生成も可能
* DOT言語をベースにしている記述方法
    * 方言がある

## graphviz

### grViz関数

```{r test_grViz, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
grViz("
digraph prac_grviz {
      //グラフ全体の設定
      graph [ rankdir = LR ]

      //ノードの設定
      node []
      a; b; c;

      //エッジの設定
      edge []

      a -> b -> c
     
}
      ")
```

---

* コメントアウトは`//`, `/* */`, `#` が使える。
* `digraph グラフ名 { グラフの情報 }`で書く
* ダウンストリーム的に上から下に順ぐりに書く
* `->`で有向, `--`で無向

---

```{r test_grViz_2, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
grViz("
      digraph gogyo {
      
      graph [ charset = 'UTF-8' ]
      
      node [ shape = 'circle']
      a [ label = '木' ];
      b [ label = '火' ];
      c [ label = '土' ];
      d [ label = '金' ];
      e [ label = '水' ];
      
      edge []
      a -> b -> c -> d -> e [ arrowhead = 'none' ]
      a -> c -> e -> b -> d -> a

      }
      ")

```


---

* `[label = 'なまえ']`で表示する名前を書きます。
* `[shape = 'circle']`でノードの形を設定します。
* `[arrowtail = 'none', arrowhead = 'none']`でエッジの設定をします。

* 五行を書いてみたのですが、全然綺麗じゃないですね。

---

```{r test_grViz_2_2, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
grViz("
      digraph gogyo_resetting {
      
      graph [ charset = 'UTF-8',
              rankdir = TB,
              // layout = dot
              // layout = neato
              // layout = twopi
              layout = circo
            ]
      
      node [ shape = 'circle',
             width = 0.9 ]
      a [ label = '木' ];
      b [ label = '火' ];
      c [ label = '土' ];
      d [ label = '金' ];
      e [ label = '水' ];
      
      edge []
      a -> b -> c -> d -> e [ arrowhead = 'none' ]
      a -> c -> e -> b -> d -> a

      
      {rank = min; a;}
      {rank = same; b; e;}
      {rank = max; c; d;}

      }
      ")

```

---

* とても惜しい感じになってますね。
* こんな感じでグラフが自動生成されてしまうため。
* 調整がかなり難しい。


## footnumber

```{r test_grViz_3, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
grViz("
      digraph c_pointer {
      
      graph [
      charset = 'UTF8',
      rankdir = LR,
      newrank = true,
      compound = true
      ]
      
      node [
      shape = 'box'
      ]
      
      subgraph cluster_a {
      
      label = '003'
      
      /*
      // 003
      003 [ label = '@@1-1' ]
      */
      // a
      a [ label = '@@1-1' ]
      }

      // *a
      pointer_pointer [ label = '@@1-2' ]
      // **a
      base_pointer_pointer [ label = '@@1-3' ]
      
      subgraph cluster_b {
      
      label = '002'
      
      /*
      // 002
      002 [ label = '@@2-1' ]
      */
      // b
      b [ label = '@@2-1' ]
      
      }
      
      // *b
      base_pointer         [ label = '@@2-2'      ]

      subgraph cluster_c {
      
      label = '001'
      
      /*
      // 001
      001 [ label = '@@3-1' ]
      */
      // c\\n114
      c [ label = '@@3-1' ]
      //      base            [ label = '114'           ]
      
      }
      
      
      
      a -> b [ lhead = cluster_b, color = red ];
      b -> c [ lhead = cluster_c,arrowtail = diamond, color = red]

      pointer_pointer -> b
      base_pointer_pointer -> c

      base_pointer -> c
      
      {rank = same; a; pointer_pointer; base_pointer_pointer;}
      {rank = same; b; base_pointer;}
      {rank = same; c;}
      
      }
      
      [1]: c( 'a\\n002', '*a\\n001', '**a\\n114')
      [2]: c( 'b\\n001', '*b\\n114')
      [3]: c( 'c\\n114')
      ")
 
```

---

* `@@`の後に数字をつける
* `@@1-1`みたいにすると複数のfootnumberをつけれる
* `[footnumber]: `で属性を設定できる
* `graph graph_name {}`の外はRの表現を使える
* Rの表現式でのエスケープとhtmlにわたす改行文字の表現で`\\n`となる


## mermaid

* `mermaid`というグラフ生成方法もある
* 記述が簡単
* 優秀
* 通常のフローチャート
* シーケンスダイアグラム
* ガントチャート
* マジで優秀
* なんどでもいう、優秀

---


```{r  ,fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
mermaid("
graph LR
    id1[四角]
    id2(角丸)
    id3{ダイヤ}
    id4>よこっちょ削り]
    id5((円))
id1 --- id2
id2 --> id3
id3 ---|こっち| id4
id3 --円だよ--> id5
")
```

---


* すっきりした書き心地
* 上から順番に書いていく
* `graph`は通常のグラフ
    * `LR`, `RL`, `TB`(`TD`), `BT`で全体の方向を指定
* 表示する文字は直接書いてOK！
* ただし、文字列を明示するには`""`でくくる
    * シングルクウォーテーションは効かない
* そのため、`mermaid('グラフ')`で全体をくくる
    
---

* 矢印はいっぱいある
    * 規則性があるのでわかりやすい
    
|無向|有向|効果|
|:---:|:-----:|:-----:|
|`---`|`-->`|ふつう|
|`-.-`|`-.->`|ドット|
|`===`|`==>`|太い|
|`---|hoge|`|`-->|hoge|`|テキストつき|
|`-- hoge ---`|`-- hoge -->`|テキストつき|
|`-.->|hoge|`|`-. hoge .->`|テキストつきドット|

## sequenceDiagram

* ダイアグラムも簡単に作れる

```{r shinkansen, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
mermaid("
sequenceDiagram
  participant aomori as 新青森
  participant kikonai as 木古内
  participant hokuto as 新函館北斗
  participant hakodate as 函館

aomori->>kikonai: 新幹線
kikonai->>hokuto: 新幹線
hokuto--xhakodate: 新幹線
hokuto->>hakodate: JR

Note over aomori,kikonai: 青函トンネル
")
```

---

* `sequenceDiagram`を書く
* `participant 名前`で各シーケンスの名前を設定
    * `participant id as 名前`でid名で扱えるようになる。(エイリアス)
* `エッジ: テキスト`でテキストを入れられる
* `Note 配置 Actor: テキスト`でメモを入れられる。
    * `left of`, `right of`, `over`
    * Actor(ノード)を2つ設定するとまたいでNoteを入れられる。

---

* 矢印はflowchartとはまた違う。
* 例のごとくいっぱいある

|無向|有向|ばってん|効果|
|:-----:|:-------:|:----:|:--------:|
|`->`|`->>`|`-x`|ふつう|
|`-->`|`-->>`|`--x`|点線|

## Gant diagram

* ガントチャートのこと

```{r feshiken, fig.width=6, fig.asp=0.618, out.width="70%", fig.align="center"}
mermaid("
        gantt
            title 基本情報
            dateFormat YYYY-MM-DD
            section 午前問題
            テキスト読み込み    :done, text, 2017-12-01, 30d
            午前の過去問              :done, kako_1, after text, 90d

            section 午後問題
            C言語               :done, Clang, 2018-02-01, 60d
            午後の過去問        :done, kako_2, 2018-02-01, 60d

            section 試験日程
            fe                  :crit, done, test, 2018-04-15, 1d
            合格発表            :      done, pass, 2018-05-16, 1d

            section 合格発表後
            IEEEEEEEEEEE        :active, IEEE, 2018-05-16, 10d
        ")

```

## パイプライン {#pipe_diagrammer}

* DiagrammeRのバージョンアップで最新版とCRAN版と関数群が変更になっているようです。
* バージョン1.0で実行してみてください。
* 今回は`?render_graph`を参考にしています。

```{r pipe_render_graph_1}
create_graph() %>%
  # 均等なツリーをつくる
  add_balanced_tree(
    # kは分岐の数, hは深度
    k = 2, h = 3) %>%
  render_graph()
```

---

```{r pipe_render_graph_2}
create_graph() %>%
  add_balanced_tree(
    k = 2, h = 3) %>%
  # layoutで構造をしていする
  render_graph(layout =
                 "nicely" #default
                 #"tree" #ツリー
                 #"circle" #円
                 #"kk" #defaultのぎゅっとしたやつ
                 #"fr" #defaultの点対称っぽい
               )
```

---

```{r pipe_render_graph_3}
create_graph() %>%
  add_balanced_tree(
    k = 2, h = 3) %>%
  # ノードのラベルを剥がす attr=NULL, nodes=NULL
  set_node_attr_to_display() %>% 
  render_graph(layout = "circle")
```

---

```{r pipe_render_graph_4}
create_graph() %>%
  # graphのノード(n)とエッジ(m)を設定する
  # 乱数でノードとエッジを決めているようなのでset_seedを設定する
  add_gnm_graph(n = 60, m = 5
                #, set_seed = 1
                ) %>% 
  render_graph(layout = "circle")
```

---

```{r pipe_render_graph_5}
create_graph() %>%
  add_balanced_tree(
    k = 2, h = 3) %>%
  # output = NULLでgrVizを利用してレンダリングされる
  # output = "visNetwork"でvisnetworkを利用してレンダリングされる
  render_graph(output = "visNetwork")
```

---

### 公式

* ここからは公式ドキュメントをベースに
* コードを修正していきます。
* 公式のドキュメントが更新されるのを待ちたい。


```{r traversal_1}
#乱数使われているみたい
graph <-
  create_graph() %>%
  add_n_nodes(
    n = 1,
    type = "a"
  ) %>% 
  add_n_nodes(
    n = 4,
    type = "b"
  ) %>% 
  add_n_nodes(
    n = 4,
    type = "c"
  ) %>% 
  add_edges_w_string(
    edges = "1->2 1->3 4->1 5->1 1->6 1->7 8->1 9->1"
  )
# View the created graph
render_graph(graph, output = "visNetwork")
```

---

```{r traversal_2_update}
update_graph <-  graph %>%
  select_nodes_by_id(nodes = 1) %>%
  trav_out(conditions = type == "c") %>%
  add_n_nodes_ws(1, direction = "from", type = "d")
render_graph(update_graph, output = "visNetwork")
```

---

```{r traversal_3}
nodes <-
  create_node_df(
    n = 9,
    type = c("fruit", "fruit", "fruit",
             "veg", "veg", "veg",
             "nut", "nut", "nut"),
    label = c("pineapple", "apple",
              "apricot", "cucumber",
              "celery", "endive",
              "hazelnut", "almond",
              "chestnut"))

edges <-
  create_edge_df(
    from = c(9, 3, 6, 2, 6, 2, 8, 2, 5, 5),
    to = c(1, 1, 4, 3, 7, 8, 1, 5, 3, 6))

graph <-
  create_graph(
    nodes_df = nodes,
    edges_df = edges)

render_graph(graph, output = "visNetwork")
```

---

```{r traversal_4_random_graph}
random_graph <-
  create_graph(directed = TRUE) %>% 
  add_gnm_graph(n = 5, m = 10, set_seed = 20) %>% 
  set_node_attrs(node_attr = "value", values = c(9, 8, 3, 5.5, 10))
random_graph %>% get_node_df()
random_graph %>% get_edge_df()
render_graph(random_graph, output = "visNetwork")
```

---

```{r traversal_5}
nodes <-
  create_node_df(
    n = 14,
    type = c("person", "person",
             "person", "person",
             "person", "fruit",
             "fruit", "fruit",
             "veg", "veg", "veg",
             "nut", "nut", "nut"),
    label = c("Annie", "Donna",
              "Justine", "Ed",
              "Graham", "pineapple",
              "apple", "apricot",
              "cucumber", "celery",
              "endive", "hazelnut",
              "almond", "chestnut"))

edges <-
  create_edge_df(
    from = sort(
      as.vector(replicate(5, 1:5))),
    to = as.vector(
      replicate(5, sample(6:14, 5))),
    rel = as.vector(
      replicate(
        5, sample(
          c("likes", "dislikes",
            "allergic_to"), 5,
          TRUE,
          c(0.5, 0.25, 0.25)))))

graph <-
  create_graph(
    nodes_df = nodes,
    edges_df = edges
    )

graph %>% render_graph(output = "visNetwork")
```

---

```{r traversal_6,eval=F}
set.seed(20)

graph <-
  create_graph(directed = TRUE) %>% 
  add_gnm_graph(10, 20,
                set_seed = 20)
  graph <-
    graph %>% 
   # select_nodes_by_id(i) %>% 
    set_node_attrs(
      node_attr = "type",
      values = sample(
        c("a", "b", "c"), count_nodes(graph), replace = TRUE))

  graph <-
    graph %>% 
    set_edge_attrs(
      from = get_edges(., return_type = "df")[i, 1],
      to = get_edges(., return_type = "df")[i, 2],
      edge_attr = "data_value",
      values = sample(
        seq(0, 8, 0.5), count_edges(graph), replace = TRUE))

# Look at the graph
graph %>% render_graph(output = "visNetwork")
```

---

```{r traversal_7}
set.seed(20)

# Create a graph with fruit,
# vegetables, nuts, and... people!
nodes <-
  create_node_df(
    n = 14,
    type = c("person", "person",
             "person", "person",
             "person", "fruit",
             "fruit", "fruit",
             "veg", "veg", "veg",
             "nut", "nut", "nut"),
    label = c("Annie", "Donna",
              "Justine", "Ed",
              "Graham", "pineapple",
              "apple", "apricot",
              "cucumber", "celery",
              "endive", "hazelnut",
              "almond", "chestnut"))

edges <-
  create_edge_df(
    from = sort(
      as.vector(replicate(5, 1:5))),
    to = as.vector(
      replicate(5, sample(6:14, 5))),
    rel = as.vector(
      replicate(
        5, sample(
          c("likes", "dislikes",
            "allergic_to"), 5,
          TRUE,
          c(0.5, 0.25, 0.25)))))

graph <-
  create_graph(
    nodes_df = nodes,
    edges_df = edges
    )

# Have a look at the graph
graph %>% render_graph(output = "visNetwork")

```

---

```{r traversal_8}
graph_allergies <-
  graph %>%
  select_nodes(
    conditions  = type == "person") %>%
  invert_selection() %>%
  trav_in_edge(
    conditions  = rel == "allergic_to") %>%
  trav_in_node() %>%
  set_node_attrs_ws(node_attr = "color", value = "red") %>%
  invert_selection() %>%
  set_node_attrs_ws(node_attr = "color", value = "green") %>%
  clear_selection() %>%
  select_nodes(
    conditions =  type == "person") %>%
  set_node_attrs_ws(node_attr = "color", value = "blue")
graph %>% get_edge_df

# Display the modified graph, where green
# nodes represent safe foods for the
# group of people (blue nodes); red nodes
# are the danger foods
graph_allergies %>% render_graph(output = "visNetwork")
```

---

```{r software_repository_1}
contributors_csv <-
  system.file("extdata", "contributors.csv",
              package = "DiagrammeR")

colnames(read.csv(contributors_csv,
                  stringsAsFactors = FALSE))

# Create a path to the CSV file containing
# information about the software projects
projects_csv <-
  system.file("extdata/projects.csv",
              package = "DiagrammeR")

colnames(read.csv(projects_csv,
                  stringsAsFactors = FALSE))

# Create a path to the CSV file with information
# about the relationships between the projects
# and their contributors
projects_and_contributors_csv <-
  system.file("extdata/projects_and_contributors.csv",
              package = "DiagrammeR")

colnames(read.csv(projects_and_contributors_csv,
                  stringsAsFactors = FALSE))

# Create the property graph by adding the CSV data to a
# new graph; the `add_nodes_from_csv()` and
# `add_edges_from_csv()` functions are used to create
# nodes and edges in the graph
graph <-
  create_graph() %>%
  set_graph_name("software_projects") %>%
  add_nodes_from_table(
    contributors_csv,
    set_type = person,
    label_col = name) %>%
  add_nodes_from_table(
    projects_csv,
    set_type = project,
    label_col = project) %>%
  add_edges_from_table(
    projects_and_contributors_csv,
    from_col = contributor_name,
    #from_mapping = "name",
    to_col = project_name,
    from_to_map = label,
    rel_col = contributor_role)

get_node_df(graph)

# View the graph
graph %>% render_graph(output = "visNetwork")
```

---

```{r software_repository_2}
graph_scale_width_edges <-
  graph %>%
  select_edges() %>%
  rescale_edge_attrs(
    edge_attr_from = "commits", edge_attr_to = "width",
    to_lower_bound = 0.5, to_upper_bound = 3.0)

# Inspect the graph's internal EDF
get_edge_df(graph_scale_width_edges)

# View the graph, larger edges and arrows
# indicate higher numbers of `commits`
graph_scale_width_edges %>% render_graph(output = "visNetwork")
```

---

```{r software_repository_3}
graph_scale_color_edges <-
  graph %>%
  select_edges() %>%
  rescale_edge_attrs(
    edge_attr_from = "commits", edge_attr_to ="color",
    to_lower_bound = "gray95", to_upper_bound =  "gray5")

# Render the graph, darker edges represent higher
# commits
graph_scale_color_edges %>% render_graph(output = "visNetwork")
```

---

```{r software_repository_4}
graph <-
  graph %>% 
  add_edge(
    get_node_ids(.,
      conditions = label == "Kim"),
    get_node_ids(.,
      conditions = label == "stringbuildeR"),
    "contributor") %>%
  select_last_edges_created() %>%
  set_edge_attrs_ws("commits", 15) %>%
  clear_selection()

# View the graph's internal EDF, the newest
# edge is at the bottom
get_edge_df(graph)


# View the graph to see the new edge
graph %>% render_graph(output = "visNetwork")
```

---

* まだまだありますが、ここでやめておきます。
* CRANからインストールした場合、バージョンはstableになるので修正版は使えない


# 20.動的処理

## 小手調べ

* 通常、Rではメモリを先に確保する
    * 静的なうごきのほうが速い、軽い
* でも文字列をオブジェクトにすることがある
    * 動的なうごきは遅い、重い
    * どれだけのメモリを確保すればいいかわからない
* Rは動的型付けの関数型言語
    * 関数型と手続き型の中間型かな

## 関数型

* `function(fun) fun()`って感じのやつ
* ほかにもラムダとか使えるらしい
* 詳しくはhaskell, F#に任せたい。
* `lambdaR`パッケージもある。

```{r function_type}
testa <- function() print("a")

testfun <- function(fun) {fun(); print(environment())}
replicate(3, testfun(testa))
```

## 匿名関数

* 名前のない関数
* `fun = function(){}`とかのやつ
* `apply`ファミリー, `prrr::map*`, `stat_function`とかで使う
* 直接は関係ないけど、`()`でくくると代入式でもリターンしてくれる

```{r func_unknown}
(test_unknown <- "Hello")
(function(var, n) {
  tmp <- var
  for(i in 1:n) {
  var <- (var + tmp/var) / 2
  }
  return(var)})(2, 10)
```




## eval, substitute, do.call

* いよいよ動的処理
* 今は、`eval`と`substitute`と`do.call`を使うのが主流らしい
* `eval`と`parse`では遅いらしい

```{r test_eval}
microbenchmark::microbenchmark(
  esd = function() eval(substitute(do.call(func, args = list(n = 30)), env = list(func = "rnorm"))),
   ep  = function() eval(parse(text = paste0("rnorm", "(", "n" ,")")), envir = list(n = 30)),
   times = 20
 )
```

* meanを見るとesdのほうが速いですね



# 他言語２

## 組み合わせ

# さいごに

---

<p id="lastpage">
今回は，他言語との連携をメインにRを紹介しました。<br/>
ここでは触れなかったことの方が多いです。<br/>
統計だけじゃない，Rを楽しみましょう！
</p>

# 付録

# 環境構築

## virtualbox

## vagrant

### rstudio-server

## Vagrantfile

## Nginx

## Shiny-server

## 参考資料

* [アート・オブ・Rプログラミング](https://www.oreilly.co.jp/books/9784873115795/)
* [R for Data Science](http://r4ds.had.co.nz/)
* [DiagrammeR](http://rich-iannone.github.io/DiagrammeR/docs.html)
* [mermaid.js](https://mermaidjs.github.io/)


